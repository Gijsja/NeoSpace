<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neo Render Prototype (Game Loop)</title>
    <script src="https://unpkg.com/@phosphor-icons/web@2.1.1"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; background: #0f172a; overflow: hidden; color: white; font-family: sans-serif; }
        #canvas-ui { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; }
        .ui-element { position: absolute; pointer-events: auto; transition: transform 0.1s linear; will-change: transform; }
        #debug { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 4px; z-index: 1000; pointer-events: auto;}
    </style>
</head>
<body>

<div id="debug">
    FPS: <span id="fps">0</span> | Objects: <span id="obj-count">0</span>
    <br>
    <button onclick="addRandomStickers(10)" class="bg-blue-500 px-2 rounded hover:bg-blue-400">+10</button>
    <button onclick="addRandomStickers(100)" class="bg-blue-700 px-2 rounded hover:bg-blue-600">+100</button>
</div>

<!-- DOM Container for interactive elements (Hybrid Approach) -->
<!-- Instead of pure canvas, we use absolute positioned DOM elements updated via a loop -->
<div id="viewport" class="relative w-full h-full overflow-hidden bg-slate-900">
    <!-- Elements injected here -->
</div>

<script>
/**
 * NEO RENDERER PROTOTYPE
 * Concept: Decouple State from DOM. 
 * Update State -> Render Loop syncs DOM (Hybrid) or Draws Canvas (Pure).
 * This PoC uses "Hybrid DOM" where the loop forces styles efficiently.
 */

class NeoState {
    constructor() {
        this.objects = new Map();
        this.nextId = 1;
        this.lastFrame = 0;
    }

    add(obj) {
        const id = this.nextId++;
        this.objects.set(id, { ...obj, id, 
            vx: (Math.random() - 0.5) * 2, 
            vy: (Math.random() - 0.5) * 2,
            rotVel: (Math.random() - 0.5) * 0.5
        });
        return id;
    }

    update(dt) {
        // Simulation Step (Physics/Logic)
        for (const [id, obj] of this.objects) {
            obj.x += obj.vx;
            obj.y += obj.vy;
            obj.rotation += obj.rotVel;

            // Bounce bounds
            if (obj.x < 0 || obj.x > window.innerWidth) obj.vx *= -1;
            if (obj.y < 0 || obj.y > window.innerHeight) obj.vy *= -1;
        }
    }
}

class NeoRenderer {
    constructor(containerId, state) {
        this.container = document.getElementById(containerId);
        this.state = state;
        this.domCache = new Map(); // Map<id, HTMLElement>
    }

    render() {
        // Sync DOM with State
        
        // 1. Create missing elements
        for (const [id, obj] of this.state.objects) {
            if (!this.domCache.has(id)) {
                const el = document.createElement('div');
                el.className = 'ui-element select-none text-4xl drop-shadow-lg cursor-pointer';
                el.innerText = obj.content;
                
                // Interaction
                el.onmousedown = () => {
                    el.style.color = 'red';
                    obj.vx *= 2; obj.vy *= 2; // Chaos input
                };

                this.container.appendChild(el);
                this.domCache.set(id, el);
            }
        }

        // 2. Update existing elements (Batch read/write?)
        // In a real framework we'd diff, here we just force transform
        for (const [id, obj] of this.state.objects) {
            const el = this.domCache.get(id);
            if (el) {
                // Using transform for composition-only reflows
                el.style.transform = `translate(${obj.x}px, ${obj.y}px) rotate(${obj.rotation}deg) scale(${obj.scale || 1})`;
            }
        }
    }
}

// --- MAIN LOOP ---

const state = new NeoState();
const renderer = new NeoRenderer('viewport', state);
const fpsEl = document.getElementById('fps');
const countEl = document.getElementById('obj-count');

let lastTime = performance.now();
let frames = 0;
let lastFpsTime = lastTime;

function loop(now) {
    const dt = now - lastTime;
    lastTime = now;

    // Fixed time step simulation could go here
    state.update(dt);
    
    // Render as fast as possible (vsync)
    renderer.render();

    // Stats
    frames++;
    if (now - lastFpsTime >= 1000) {
        fpsEl.innerText = frames;
        countEl.innerText = state.objects.size;
        frames = 0;
        lastFpsTime = now;
    }

    requestAnimationFrame(loop);
}

// --- SETUP ---

function addRandomStickers(count) {
    const icons = ["ğŸ”¥", "âœ¨", "ğŸ¨", "ğŸ’œ", "ğŸš€", "ğŸ’»", "ğŸ’¾", "ğŸŒˆ", "ğŸ‘¾", "â­", "ğŸµ", "ğŸ•"];
    for(let i=0; i<count; i++) {
        state.add({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            rotation: Math.random() * 360,
            content: icons[Math.floor(Math.random() * icons.length)]
        });
    }
}

// Start
addRandomStickers(50);
requestAnimationFrame(loop);

</script>
</body>
</html>
