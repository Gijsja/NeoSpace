{% extends "base.html" %}

{% block title %}Ambient Lobby{% endblock %}
{% block page_title %}Lobby{% endblock %}

{% block main_container %}
<div class="relative w-full h-full bg-black overflow-hidden select-none">
    <!-- Canvas Layer -->
    <canvas id="lobby-canvas" class="absolute inset-0 block"></canvas>

    <!-- UI Overlay (Pointer Events None to let clicks pass to canvas if needed, but we want hover on text maybe? No, decorative) -->
    <div class="absolute bottom-8 left-8 pointer-events-none z-10 mix-blend-difference">
        <h2 class="text-6xl font-black text-white tracking-tighter opacity-80">LOBBY</h2>
        <div class="flex items-center gap-4 mt-2 font-mono text-xs text-white">
            <span class="px-2 py-1 border border-white/30 rounded backdrop-blur">
                <span id="user-count" class="font-bold text-[#00ff88]">0</span> SOULS
            </span>
            <span class="animate-pulse text-white/50">LIVE SYSTEM</span>
        </div>
    </div>

    <!-- Tip -->
    <div class="absolute top-8 right-8 pointer-events-none z-10 text-right opacity-0 transition-opacity duration-1000"
        id="intro-tip">
        <p class="text-xs font-mono text-white/50">HOVER TO REVEAL IDENTITY</p>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script type="module">
    import { IsoGrid } from '/static/js/lobby/IsoGrid.js';

    const canvas = document.getElementById('lobby-canvas');
    const ctx = canvas.getContext('2d');
    const userCountEl = document.getElementById('user-count');
    const introTip = document.getElementById('intro-tip');

    // Grid Setup
    let grid;
    const catImages = {};
    const catFiles = [
        'ash.png', 'beans.png', 'beans_grumpy.png', 'beans_playful.png',
        'beans_zen.png', 'delta.png', 'glitch.png', 'miso.png',
        'neon.png', 'patch.png', 'tofu.png'
    ];

    async function preloadAssets() {
        const promises = catFiles.map(file => {
            return new Promise((resolve) => {
                const img = new Image();
                img.src = `/static/images/cats/${file}`;
                img.onload = () => {
                    const name = file.split('.')[0];
                    catImages[name] = img;
                    resolve();
                };
            });
        });
        await Promise.all(promises);
        catImages['default'] = catImages['ash']; // Fallback
    }

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        if (grid) {
            // Recenter grid
            grid.originX = canvas.width / 2;
            grid.originY = canvas.height / 4;
        }
    }

    // Input Handling
    canvas.addEventListener('click', (e) => {
        if (!grid) return;
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;

        const coords = grid.fromScreen(screenX, screenY);
        console.log('Clicked tile:', coords);

        // TODO: Send move command via socket
        // For now, simulate local move of "Self"
        // grid.addEntity({ id: 'me', x: coords.col, y: coords.row, ... });
    });

    async function init() {
        await preloadAssets();

        resize();
        window.addEventListener('resize', resize);

        grid = new IsoGrid(ctx, {
            cols: 20,
            rows: 20,
            tileWidth: 64,
            tileHeight: 32,
            originX: canvas.width / 2,
            originY: canvas.height / 4
        });
        grid.bakeAssets(catImages);

        // Start Loop
        requestAnimationFrame(loop);

        // Start Polling
        fetchUsers();
        setInterval(fetchUsers, 2000);

        // Show tip
        setTimeout(() => introTip.classList.remove('opacity-0'), 1000);
    }

    function loop() {
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (grid) {
            grid.update();
            grid.draw();
        }

        requestAnimationFrame(loop);
    }

    // Data Fetching
    async function fetchUsers() {
        try {
            const res = await fetch('/lobby/users');
            if (res.ok) {
                const data = await res.json();
                userCountEl.textContent = data.users.length;
                updateEntities(data.users);
            }
        } catch (e) {
            console.error("Lobby sync error:", e);
        }
    }

    function updateEntities(users) {
        if (!grid) return;

        const validIds = new Set(users.map(u => u.id));

        // Remove left users
        grid.entities = grid.entities.filter(e => validIds.has(e.id));

        // Add/Update users
        users.forEach((u, index) => {
            // Stable pseudorandom pos based on ID if not provided
            // In real app, position comes from server
            const uidStr = String(u.id);
            const seed = uidStr.charCodeAt(0) + uidStr.charCodeAt(uidStr.length - 1);
            const rCol = seed % 20;
            const rRow = (seed * 13) % 20;

            const existing = grid.entities.find(e => e.id === u.id);
            if (!existing) {
                grid.addEntity({
                    id: u.id,
                    x: rCol,
                    y: rRow,
                    type: 'cat',
                    meta: {
                        username: u.username,
                        avatar: 'ash', // Default for now, ideally fetch connection to specific cat
                        color: 'red'
                    }
                });
            }
            // Else update position if standard socket payload had it
        });

        // Add Mock Ghost if empty (Dev)
        if (users.length === 0 || users.length < 3) {
            if (!grid.entities.find(e => e.id === 'ghost-1')) {
                grid.addEntity({
                    id: 'ghost-1',
                    x: 5, y: 5,
                    type: 'cat',
                    meta: { username: 'GHOST_CAT', avatar: 'miso' }
                });
            }
        }

        // Add Self if active (Mock)
        // grid.addEntity(...)
    }

    init();

</script>
{% endblock %}